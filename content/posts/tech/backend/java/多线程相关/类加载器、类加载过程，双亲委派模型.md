---
title: "类加载器、类加载过程，双亲委派模型"
date: 2016-04-01
draft: false
layout: posts
tags: ["Java","多线程","并发处理"]
---

## 类加载过程
![image.png](https://raw.githubusercontent.com/Leowuqunqun/img/master/image202305262230253.png)
### 加载
![image.png](https://raw.githubusercontent.com/Leowuqunqun/img/master/image202305262231943.png)
虚拟机规范上面这 3 点并不具体，因此是非常灵活的。比如："通过全类名获取定义此类的二进制字节流" 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 ZIP 包中读取（日后出现的 JAR、EAR、WAR 格式的基础）、其他文件生成（典型应用就是 JSP）等等。
**一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法)。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。**
加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。
### 验证
验证阶段主要确保被加载的类的正确性。这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：
（1）**文件格式验证**：验证字节流是否符合Class文件格式的规范，而且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：

- 是否以**0xCAFEBABE**开头。
- 主、次版本号是否在当前虚拟机的处理范围之内。
- 常量池中的常量是否有不被支持的常量类型。
- 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
- Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。

第一阶段的验证点远不止这些，该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区内，格式上符合描述一个Java类型信息的要求。该阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段都是基于方法区的存储结构进行的，不会再直接操作字节流。
（2）**元数据验证**：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，这个阶段可能包括的验证点：

- 这个类是否有除了java.lang.Object之外的父类。
- 这个类的父类是否继承了不允许被继承的类（被final修饰的类）。
- 如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法。
- 类中的字段、方法是否与父类产生矛盾。

（3）**字节码验证**：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如：

- 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。
- 保证跳转指令不会跳转到方法体以外的字节码指令上。
- 保证方法体中的类型转换是有效的。

（4）**符号引用验证**：最后一个阶段的校验发生在解析阶段，其对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验以下内容：

- 符号引用中通过字符串描述的全限定名是否能找到对应的类。
- 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
- 符号引用中的类、字段、方法的访问性是否可被当前类访问。

符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出异常。该阶段是一个非常重要的、但不是一定必要的阶段。
### 准备
![image.png](https://raw.githubusercontent.com/Leowuqunqun/img/master/image202305262231564.png)
准备阶段主要**为类的静态变量分配内存并将其初始化为默认值**，这些内存都将在**方法区**中分配。
该阶段有两点需要注意：
（1）首先，这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。
（2)其次，这里所设置的初始值通常是数据类型默认的初始值，而不是被在Java代码中被显式地赋予的值。这里还需要注意如下几点：

- 对**基本数据类型**来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
- 对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被**final**修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。
- 对于**引用数据类型**来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。
- 如果在**数组**初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。

如果类字段的字段属性表中存在ConstantValue属性（同时被final和static修饰），那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设类变量value被定义为：
```java
public static final int value = 123; 
```
编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。
### 解析

![image.png](https://raw.githubusercontent.com/Leowuqunqun/img/master/image202305262231022.png)
解析阶段是虚拟机**将常量池内的符号引用替换为直接引用**的过程。**符号引用**就是一组符号来描述目标，可以是任何字面量；**直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。下面将讲解前面4种引用的解析过程。

- **类或接口的解析**

假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，虚拟机需要以下3个步骤：
（1）如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。
（2）如果C是一个数组类型，并且数组的元素类型为对象，那将会按照第1点的规则加载数组元素类型。
（3）如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。

- **字段解析**

要解析一个未被解析过的字段符号引用，首先将会对字段所属的类或接口的符号引用进行解析。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索：
（1）如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
（2）否则，如果在C中实现了接口，就会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
（3）否则，如果C不是java.lang.Object的话，就会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
（4）否则，查找失败，抛出**java.lang.NoSuchFieldError**异常。
最后，如果查找过程成功返回了直接引用，就会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出**java.lang.IllegalAccessError**异常。

- **类方法解析**

类方法解析也需要先解析出类方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索：
（1）类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现C是个接口，直接抛出异常。
（2）否则，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
（3）否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
（4）否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，查找结束，抛出异常。
（5）否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。
最后，如果查找过程成功返回了直接引用，就会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。

- **接口方法解析**

接口方法解析也需要先解析出接口方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：
（1）如果在接口方法表中发现C是个类而不是接口，直接抛出异常。
（2）否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
（3）否则，在接口C的父接口中递归查找，直到java.lang.Object类为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
（4）否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。
由于接口中的所有方法默认都是public的，所以不存在访问权限的问题。

### 初始化
![image.png](https://raw.githubusercontent.com/Leowuqunqun/img/master/image202305262232186.png)
初始化是指**为类的静态变量赋予正确的初始值**，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：
（1）声明类变量时指定初始值；
（2）使用静态代码块为类变量指定初始值。
JVM初始化步骤：
（1）假如这个类还没有被加载和连接，则程序先加载并连接该类；
（2）假如该类的直接父类还没有被初始化，则先初始化其直接父类；
（3)假如类中有初始化语句，则系统依次执行这些初始化语句。
类初始化时机：只有当对类主动使用的时候才会导致类的初始化，类的主动使用包括以下6种：

- 创建类的实例，也就是new的方式；
- 访问某个类或接口的静态变量，或者对该静态变量赋值；
- 调用类的静态方法；
- 反射（如Class.forName("…")）；
- 初始化某个类的子类，则其父类也会被初始化；
- Java虚拟机启动时被标明为启动类的类，直接使用java.exe命令来运行某个主类。

## 类加载器总结
JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader：

1. **BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由 C++实现，负责加载 %JAVA_HOME%/lib目录下的 jar 包和类或者被 -Xbootclasspath参数指定的路径中的所有类。
2. **ExtensionClassLoader(扩展类加载器)** ：主要负责加载 %JRE_HOME%/lib/ext 目录下的 jar 包和类，或被 java.ext.dirs 系统变量所指定的路径下的 jar 包。
3. **AppClassLoader(应用程序类加载器)** ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

## 双亲委派模型
### 介绍
每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 **双亲委派模型** 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。
![image.png](https://raw.githubusercontent.com/Leowuqunqun/img/master/image202305262232008.png)
### 好处
双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。

### 打破双亲委派模型
自定义加载器的话，需要继承 ClassLoader 。如果我们不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 loadClass() 方法

### 自定义类加载器
除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader。如果我们要自定义自己的类加载器，很明显需要继承 ClassLoader。
## 参考

- 《深入理解Java虚拟机（第2版）》
- [（JVM）Java虚拟机：类加载的5个过程](https://www.jianshu.com/p/3ca14ec823d7)



